# ADR 001: JSON Reference Resolution System

## Status
Proposed

## Context
The `drawing-standards.json` file defines drawing standards with a normalized structure using `$ref:` references to avoid duplication:

```json
{
  "typography": {
    "fontFamilies": {
      "primary": {"name": "Arial", "fallback": "Helvetica, sans-serif"}
    },
    "fontSizes": {
      "standard": 16
    }
  },
  "elements": {
    "door": {
      "requiredMetadata": {
        "childElements": {
          "label": {
            "fontFamily": "$ref:typography.fontFamilies.primary",
            "fontSize": "$ref:typography.fontSizes.standard"
          }
        }
      }
    }
  }
}
```

This **normalized** format is great for:
- ✅ Single source of truth (change Arial once, applies everywhere)
- ✅ DRY principle
- ✅ Human readability

However, it requires **double lookup** when used:
1. Read element spec: `"fontFamily": "$ref:typography.fontFamilies.primary"`
2. Resolve reference: Look up `typography.fontFamilies.primary` → get `"Arial"`

## Decision
Implement a **two-format system**:

### 1. Source Format (Normalized)
- **File**: `code/drawing-standards.json`
- **Purpose**: Human-editable, version-controlled source of truth
- **Structure**: Uses `$ref:` references for reusability
- **Maintained by**: Humans (via text editor)

### 2. Resolved Format (Denormalized)
- **File**: `code/drawing-standards-resolved.json` (generated)
- **Purpose**: Ready-to-use by applications, no lookups needed
- **Structure**: All `$ref:` references replaced with actual values
- **Generated by**: Go program

### Workflow
```
drawing-standards.json (normalized)
          ↓
   [resolve-refs tool]
          ↓
drawing-standards-resolved.json (denormalized)
          ↓
   [used by applications]
```

## Implementation

### Tool: `resolve-refs`
**Language**: Go  
**Location**: `code/tools/resolve-refs/`  
**Input**: `code/drawing-standards.json`  
**Output**: `code/drawing-standards-resolved.json`

**Functionality**:
1. Load normalized JSON
2. Parse `$ref:` strings (format: `$ref:path.to.value`)
3. Resolve each reference by path lookup
4. Replace `$ref:` with actual value
5. Write denormalized JSON

**Example transformation**:
```go
// Input
{
  "fontFamily": "$ref:typography.fontFamilies.primary"
}

// Resolution
lookupPath("typography.fontFamilies.primary") 
  → {"name": "Arial", "fallback": "Helvetica, sans-serif"}

// Output  
{
  "fontFamily": "Arial",
  "fontFamilyFallback": "Helvetica, sans-serif"
}
```

### JSON Schema
Both formats should validate against a JSON Schema:
- **File**: `code/schemas/drawing-standards.schema.json`
- **Validates**: Structure, required fields, data types
- **Used by**: Go tool, CI/CD pipeline

### Git Workflow
```bash
# .gitignore
code/drawing-standards-resolved.json   # Generated, don't commit

# Pre-commit hook (or CI/CD)
cd code/tools/resolve-refs
go run . ../../drawing-standards.json ../../drawing-standards-resolved.json
```

## Consequences

### Positive
✅ **Best of both worlds**: Normalized for editing, denormalized for use  
✅ **No runtime lookups**: Applications read resolved JSON directly  
✅ **Type safety**: Go code provides compile-time validation  
✅ **Consistency**: Generated file is always correct  
✅ **Cacheable**: Resolved file can be distributed, cached

### Negative
❌ **Build step required**: Must run tool after editing source  
❌ **Two files to maintain**: Source + generated (mitigated by automation)  
❌ **Complexity**: Adds a build/transform step to workflow

### Neutral
⚪ **Generated file**: Could be committed or generated on-demand  
⚪ **Tool language**: Go chosen for type safety, but could be any language

## Alternatives Considered

### 1. Runtime Resolution
**Rejected**: Would require double lookup every time, slow and complex

### 2. No References (Fully Denormalized Source)
**Rejected**: Violates DRY, hard to maintain, error-prone

### 3. JSON Schema $ref
**Rejected**: JSON Schema $ref is for schema validation, not data references

### 4. YAML with Anchors
**Rejected**: YAML anchors work within same file, not across paths; JSON is standard for web

## Notes
- The `$ref:` syntax is custom, not JSON-standard (JSON has no built-in reference system)
- Path format: `$ref:section.subsection.key` uses dot notation
- Arrays can be referenced: `$ref:typography.fontSizes.standard` → 16
- Objects can be referenced: `$ref:typography.fontFamilies.primary` → `{"name":"Arial",...}`

## Related
- JSON Schema: https://json-schema.org/
- Go JSON libraries: encoding/json (stdlib)
- Path lookup: github.com/tidwall/gjson (for JSON path queries)

## Future Enhancements
- Support array indexing: `$ref:elements[0].name`
- Support relative refs: `$ref:../sibling/value`
- Circular reference detection
- Reference validation (ensure target exists)

---

**Date**: 2025-10-30  
**Author**: Claude (AI Assistant)  
**Reviewers**: [To be added]
